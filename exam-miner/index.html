<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0" name="viewport"/>
  <!---script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/pdfmake.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/vfs_fonts.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.4/purify.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-pdfmake/2.1.1/html-to-pdfmake.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/html-docx-js/dist/html-docx.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<!-- DOCX -->
<script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
<!-- XLSX/CSV -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<!-- PPTX unzip/XML read -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<!-- PDF.js -->
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script>
  // Must match the pdf.min.js version:
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
</script>
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  
  <title>Exam Prompt Generator with TOS</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px;  margin: auto; }
    #secTitle { border-bottom: 1px solid #ccc; padding-bottom: 5px; }
    label { display: block; margin-top: 10px; }
    input, select, textarea { width: 100%; padding: 6px; margin-top: 5px; }
    .checkbox-group, .difficulty-group { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px; }
    button { padding: 10px 15px; margin-top: 20px; }
    pre { background: #f0f0f0; padding: 10px; white-space: pre-wrap; }
  </style>
</head>
<body>
<div style="margin-left: 30%; max-width: 700px;">
<b style="color: red">Welcome to ExamMiner 2.0!</b>
  <p>System version 1.0.2</p>
  <h2 id="secTitle">Section A: Upload Learning Material</h2>
  <label>Upload File (PDF, DOCX, PPTX): <input type="file" id="material" /></label>
  <label>Subject: <input type="text" id="subject" /></label>
  <label>Topic/Title: <input type="text" id="topic" /></label>
  <label>Grade Level: <input type="text" id="grade" /></label>

  <h2>Section B: Choose Exam Type</h2>
  <div class="checkbox-group">
    <label><input type="checkbox" value="Multiple Choice" class="format" /> Multiple Choice</label>
    <label><input type="checkbox" value="True or False" class="format" /> True or False</label>
    <label><input type="checkbox" value="Identification" class="format" /> Identification</label>
    <label><input type="checkbox" value="Matching Type" class="format" /> Matching Type</label>
    <label><input type="checkbox" value="Essay" class="format" /> Essay</label>
  </div>

  <h2>Section C: Configure Exam</h2>
  <label>Number of Questions: <input type="number" value="20" id="questionCount" min="1" /></label>

  <label>Difficulty:
    <div class="difficulty-group">
      <label><input type="radio" name="difficulty" value="Easy" /> Easy</label>
      <label><input type="radio" name="difficulty" value="Medium" /> Medium</label>
      <label><input type="radio" name="difficulty" value="Hard" /> Hard</label>
    </div>
  </label>

  <label><input type="checkbox" id="shuffle" /> Shuffle Questions</label>
  <label><input type="checkbox" id="answerKey" /> Include Answer Key</label>

  <h2>Select AI Model</h2>
  <select id="model">
    <option value="deepseek/deepseek-r1:free">DeepSeek R1</option>
    <option value="deepseek/deepseek-chat-v3-0324:free">DeepSeek V3</option>
    <option value="mistralai/mistral-small-3.1-24b-instruct:free">Mistral 3.1</option>
    <option value="google/gemini-2.5-pro-exp-03-25:free">Gemini 2.5 Pro</option>
    <option value="bytedance-research/ui-tars-72b:free">UI-TARS 72B</option>
  </select>

  <h2>Section C-1: Table of Specifications</h2>
<p style="margin:6px 0 10px">
  Add topics and set percent per cognitive level. Row Total must be 100%.
</p>

<table id="tosTable" border="1" cellpadding="6" cellspacing="0" style="width:100%; border-collapse:collapse">
  <thead>
    <tr>
      <th style="width:28%">Content Area / Topic</th>
      <th style="width:12%">Weight % (Topic)</th>
      <th>Remember/Understand %</th>
      <th>Apply/Analyze %</th>
      <th>HOTS %</th>
      <th>Row Total</th>
      <th></th>
    </tr>
  </thead>
  <tbody id="tosBody">
    <tr>
      <td><input placeholder="e.g., Chapter 1: Networking Basics" /></td>
      <td><input type="number" min="0" max="100" step="1" value="25" /></td>
      <td><input type="number" min="0" max="100" step="1" value="40" /></td>
      <td><input type="number" min="0" max="100" step="1" value="40" /></td>
      <td><input type="number" min="0" max="100" step="1" value="20" /></td>
      <td class="rowTotal">100%</td>
      <td><button type="button" onclick="removeTosRow(this)">✖</button></td>
    </tr>
  </tbody>
</table>

<div style="margin-top:8px; display:flex; gap:8px">
  <button type="button" onclick="addTosRow()">Add Topic</button>
  <button type="button" onclick="validateTOS()">Validate TOS</button>
  <span id="tosStatus" style="font-style:italic; color:#555"></span>
</div>


  <h2>Section D: Generate & Edit</h2>
  <button onclick="generateExam()">Generate Exam</button>

  <h3>Generated Exam:</h3>
  <button onclick="downloadPDF()">Download exam as PDF</button>
  <button onclick="downloadDOCX()">Download as DOCX</button>

  <div id="loader" style="display:none; margin-top: 20px; font-style: italic; color: gray;"></div>
  <!-- Advanced Toolbar -->
<div style="margin-bottom: 10px;">
  <button onclick="exec('bold')"><b><i class="fas fa-bold"></i></b></button>
  <button onclick="exec('italic')"><i><i class="fas fa-italic"></i></i></button>
  <button onclick="exec('underline')"><u><i class="fas fa-underline"></i></u></button>
  
  <select style="width:100px" onchange="changeFontSize(this.value)">
    <option value="">Font Size</option>
    <option value="12px">6px</option>
    <option value="14px">7px</option>
    <option value="16px">8px</option>
    <option value="18px">9px</option>
    <option value="20px">10px</option>
    <option value="22px">11px</option>
    <option value="24px">12px</option>
    <option value="26px">13px</option>
    <option value="28px">14px</option>
    <option value="30px">15px</option>
    <option value="32px">16px</option>
    <option value="36px">18px</option>
    <option value="48px">24px</option>
    <option value="64px">32px</option>
    <option value="72px">36px</option>
  </select>
  
  <button onclick="exec('insertUnorderedList')"><i class="fas fa-list-ul"></i></button>
  <button onclick="exec('insertOrderedList')"><i class="fas fa-list-ol"></i></button>
  
  <button onclick="toggleHeading('H1')">H1</button>
  <button onclick="toggleHeading('H2')">H2</button>
  <button onclick="toggleHeading('H3')">H3</button>
  
  <button onclick="exec('justifyLeft')"><i class="fas fa-align-left"></i></button>
  <button onclick="exec('justifyCenter')"><i class="fas fa-align-center"></i></button>
  <button onclick="exec('justifyRight')"><i class="fas fa-align-right"></i></button>
  
  <button onclick="copyToClipboard()"><i class="fas fa-copy"></i></button>
  
  </div>
  
</div>
  <!-- Editable Exam Output -->
    <page size="A4" id="pdf-output" style="white-space: pre-wrap; border: 1px solid #ccc; padding: 100px; "><div id="output" contenteditable="true" style="outline: none; font-family: Arial, sans-serif; font-size: 14pt; line-height: 1.6;"></div></page>
  
  <!---div id="pdf-output" style="white-space: pre-wrap;">
  <pre id="output"></pre>
  </div-->

  <style>
page {
  background: white;
  display: block;
  margin: 10px 10%;
  margin-bottom: 0.5cm;
  box-shadow: 0 0 0.5cm rgba(0,0,0,0.5);
}
page[size="A4"] {  
  width: 21cm;
  height: 29.7cm;
}

    button {
      padding: 6px 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
    }
  
    button:hover {
      background: #e0e0e0;
    }
  
    #output:focus {
      outline: none;
    }
  </style>
  
  <script>
function exec(command, value = null) {
    document.execCommand(command, false, value);
  }

  function copyToClipboard() {
    const el = document.getElementById("output");
    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(el);
    selection.removeAllRanges();
    selection.addRange(range);
    document.execCommand("copy");
    selection.removeAllRanges();
    alert("Copied to clipboard!");
  }

  function toggleHeading(tag) {
  const selection = window.getSelection();
  if (!selection.rangeCount) return;

  const range = selection.getRangeAt(0);
  let node = range.startContainer;

  if (node.nodeType === 3) node = node.parentNode;

  // Walk up DOM to find a block element
  while (node && node !== document && !/^H[1-6]$/.test(node.tagName)) {
    node = node.parentNode;
  }

  if (node && node.tagName === tag) {
    // Remove heading by replacing with span (no margin)
    const span = document.createElement("span");
    span.innerHTML = node.innerHTML;
    node.parentNode.replaceChild(span, node);

    // Restore cursor position
    const newRange = document.createRange();
    newRange.selectNodeContents(span);
    newRange.collapse(true);
    selection.removeAllRanges();
    selection.addRange(newRange);
  } else {
    document.execCommand("formatBlock", false, tag);
  }
}



  function changeFontSize(size) {
    const span = document.createElement("span");
    span.style.fontSize = size;
    span.textContent = window.getSelection().toString();
    const range = window.getSelection().getRangeAt(0);
    range.deleteContents();
    range.insertNode(span);
  }
  /*
    function toggleAlign(alignment) {
      const current = document.queryCommandValue("justifyCenter");
      if (alignment === 'center') {
        document.execCommand("justifyCenter", false, null);
      } else if (alignment === 'left') {
        document.execCommand("justifyLeft", false, null);
      }
    }
    
    function toggleBold() {
      document.execCommand("bold", false, null);
    }
    
    function toggleItalic() {
      document.execCommand("italic", false, null);
    } */
    </script>
    


    <script>

function downloadDOCX() {
  const content = document.getElementById("output").innerHTML;
  const fname = document.getElementById("topic").value || "exam_paper";

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <style>
          body {
            font-family: Arial, sans-serif;
            font-size: 14pt;
            line-height: 1.6;
          }
          h1, h2, h3 {
            font-weight: bold;
            margin: 1em 0 0.5em;
          }
          ul, ol {
            margin-left: 20px;
          }
          p, span, div {
            margin: 0;
            padding: 0;
          }
          img {
            max-width: 100%;
            height: auto;
          }
        </style>
      </head>
      <body>${content}</body>
    </html>
  `;

  try {
    const converted = window.htmlDocx.asBlob(html);
    window.saveAs(converted, fname + ".docx");
  } catch (e) {
    alert("Failed to export DOCX. Check html-docx-js and FileSaver.js are loaded.");
    console.error(e);
  }
}



async function downloadPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    const title = (document.getElementById("topic").value || "Exam Paper").toUpperCase();
    const content = document.getElementById("output").innerText.trim();

    // Title
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.text(title, 105, 20, { align: "center" });

    // Body
    doc.setFontSize(12);
    doc.setFont("helvetica", "normal");

    const lines = doc.splitTextToSize(content, 180); // Wrap text within 180mm
    doc.text(lines, 15, 30);

    // Save the PDF
    doc.save(`${title}.pdf`);
  }

/*
function downloadPDF() {
  const fname = document.getElementById("topic").value || "exam_paper";
  const content = document.getElementById("output").innerHTML;

  // Create a temporary element to parse the HTML
  const temp = document.createElement("div");
  temp.innerHTML = content;

  // Convert using htmlToPdfmake
  const pdfContent = htmlToPdfmake(temp.innerHTML);

  const docDefinition = {
    content: [
      { text: fname.toUpperCase(), style: 'header', alignment: 'center', margin: [0, 0, 0, 10] },
      ...pdfContent
    ],
    styles: {
      header: { fontSize: 16, bold: true }
    },
    defaultStyle: { fontSize: 12 },
    pageSize: 'A4',
    pageMargins: [40, 60, 40, 60]
  };

  pdfMake.createPdf(docDefinition).download(fname + ".pdf");
} 
  */

  /*
function downloadPDF() {
  const element = document.getElementById("pdf-output");
    setTimeout(() => {
  var fname = document.getElementById("topic").value || "exam_paper";
  if(fname == null) { fname = "exam_paper"; }
  else { fname = fname + ".pdf"; }
  
  const opt = {
    margin:       0.5,
    filename:     fname,
    image:        { type: 'jpeg', quality: 0.98 },
    html2canvas:  { scale: 2, logging: true, useCORS: true },
    jsPDF:        { unit: 'in', format: 'letter', orientation: 'portrait' },
    pagebreak: {mode: ['avoid-all', 'css', 'legacy']}
  };
  html2pdf().set(opt).from(element).save();
    }, 200); // 200ms delay
}
*/
    
//const apikey = "Bearer sk-or-v1-ac32c0037d4ff843cbc8354300d4c95()d7d750066b37()cfb15b25d3b11893e9889=123"; pang gulo yung () at =123
const encoded = "QmVhcmVyIHNrLW9yLXYxLWFjMzJjMDAzN2Q0ZmY4NDNjYmM4MzU0MzAwZDRjOTVkN2Q3NTAwNjZiMzdjZmIxNWIyNWQzYjExODkzZTk4ODk=";
const apikey = window.atob(encoded);
      
function setLoader(message) {
  const loader = document.getElementById("loader");
  loader.textContent = message;
  loader.style.display = "block";
}

function hideLoader() {
  document.getElementById("loader").style.display = "none";
}

      // ========= update: validate and convert TOS ======

function readTOS(){
  const rows = Array.from(document.querySelectorAll('#tosBody tr'));
  const tos = rows.map(r=>{
    const [topicEl, wEl, ruEl, aaEl, hotEl] = r.querySelectorAll('input');
    return {
      topic: (topicEl.value||'').trim(),
      topicWeight: Number(wEl.value||0),
      RU: Number(ruEl.value||0),
      AA: Number(aaEl.value||0),
      HOTS: Number(hotEl.value||0),
      rowEl: r
    };
  }).filter(r=>r.topic);
  return tos;
}

// live validation update
document.getElementById('tosBody').addEventListener('input', () => validateTOS());

      
function validateTOS(){
  const tos = readTOS();
  const status = document.getElementById('tosStatus');
  if(!tos.length){ status.textContent = 'Add at least one topic.'; status.style.color = 'crimson'; return false; }

  // Topic weights must sum ~100
  const weightSum = tos.reduce((s,t)=>s+t.topicWeight,0);
  // Each row RU+AA+HOTS must be 100
  let ok = true;
  tos.forEach(t=>{
    const rowSum = t.RU + t.AA + t.HOTS;
    const cell = t.rowEl.querySelector('.rowTotal');
    cell.textContent = rowSum + '%';
    cell.style.color = (rowSum===100)? '#0a0' : 'crimson';
    if(rowSum!==100) ok=false;
  });

  const near100 = Math.abs(weightSum-100) <= 1; // allow tiny rounding slack
  if(!near100) ok=false;

  if(ok){
    status.textContent = `TOS looks good. Topic weights total ${weightSum}%.`;
    status.style.color = '#0a0';
    return true;
  } else {
    status.textContent = `Fix TOS: Topic weights = ${weightSum}% (must be ~100), and each row must total 100%.`;
    status.style.color = 'crimson';
    return false;
  }
}

// Largest Remainder Method to turn percentages into integers that hit the target exactly
function apportion(total, percents){
  const raw = percents.map(p => (p/100)*total);
  const floors = raw.map(Math.floor);
  let used = floors.reduce((s,x)=>s+x,0);
  const rema = raw.map((x,i)=>({i, r:x - Math.floor(x)}))
                  .sort((a,b)=>b.r - a.r);
  const out = floors.slice();
  let k = 0;
  while(used < total && k < rema.length){ out[rema[k].i]++; used++; k++; }
  return out;
}

// Allocate exact item counts per (topic, level)
function allocateItemsByTOS(totalQuestions){
  const tos = readTOS();
  // 1) Items per topic by topic weight
  const perTopic = apportion(totalQuestions, tos.map(t=>t.topicWeight));
  // 2) For each topic, split into RU/AA/HOTS
  return tos.map((t, idx)=>{
    const topicTotal = perTopic[idx];
    const perLevel = apportion(topicTotal, [t.RU, t.AA, t.HOTS]);
    return {
      topic: t.topic,
      total: topicTotal,
      RU: perLevel[0],
      AA: perLevel[1],
      HOTS: perLevel[2]
    };
  });
}



      // ====================


      // ================ NEW UPDATE =============
// Split N items across selected formats (fair apportionment)
function distributeAcrossFormats(total, formats){
  if (formats.length === 1) return {[formats[0]]: total};
  const pct = Array(formats.length).fill(100 / formats.length);
  const counts = apportion(total, pct);
  const out = {};
  formats.forEach((f, i) => out[f] = counts[i]);
  return out;
}

// Extract numbered questions from plain text; returns {items:[], answerKeyText:""}
function extractQuestions(block){
  // Very simple parser: split on lines that look like "1. ...", "2) ...", etc.
  const lines = block.split(/\r?\n/);
  const q = [];
  const answerLines = [];
  let inAnswerKey = false;

  for (let line of lines){
    const trimmed = line.trim();
    if (!trimmed) continue;
    const isAnswerHeader = /^answer\s*key[:\s]?$/i.test(trimmed);
    if (isAnswerHeader) { inAnswerKey = true; continue; }
    if (inAnswerKey) { answerLines.push(trimmed); continue; }

    // Question start
    if (/^\d+[\.\)]\s+/.test(trimmed) || /^_+\s*\d+[\.\)]\s+/.test(trimmed)){
      q.push(trimmed);
    } else if (q.length){
      // Append continuation lines (choices, stems) to the last question
      q[q.length - 1] += "\n" + trimmed;
    }
  }
  return { items: q, answerKeyText: answerLines.join("\n") };
}




function buildCellTasks(plan, selectedFormats, meta){
  // plan = [{topic, total, RU, AA, HOTS}]
  // returns an array of {topic, level, format, count, prompt}
  const tasks = [];

  for (const row of plan){
    const levels = [
      { key: 'RU', label: 'Remember/Understand', count: row.RU },
      { key: 'AA', label: 'Apply/Analyze',       count: row.AA },
      { key: 'HOTS', label: 'Higher-Order',      count: row.HOTS },
    ];

    for (const L of levels){
      if (L.count <= 0) continue;
      const perFormat = distributeAcrossFormats(L.count, selectedFormats);
      for (const [fmt, cnt] of Object.entries(perFormat)){
        if (cnt <= 0) continue;

        const fmtGuidance = (() => {
          if (fmt === "Multiple Choice") return "Multiple Choice with choices A–D.";
          if (fmt === "True or False") return "True/False. Start each line with an underscore before the number.";
          if (fmt === "Identification") return "Identification. Provide a short blank line for the answer.";
          if (fmt === "Matching Type") return "Matching Type. Provide pairs and clear instructions.";
          if (fmt === "Essay") return "Essay. Provide 1–3 sentence prompts; include blank lines.";
          return fmt + ".";
        })();

        const prompt = `
Generate exactly ${cnt} ${fmt} questions for the topic "${row.topic}" at cognitive level "${L.label}".
Subject: ${meta.subject || "(unspecified)"}
Course Topic: ${meta.topic || "(unspecified)"}
Grade Level: ${meta.grade || "(unspecified)"}

STRICT REQUIREMENTS:
- Output ONLY the ${fmt} items, numbered 1..${cnt}, plain text (no markdown, no extra commentary).
- ${fmtGuidance}
- Do not include any other formats or sections.
- Do not include an Answer Key for this block.

Style:
- Clear, unambiguous wording.
- ${L.key === 'RU' ? 'Focus on factual recall/definitions.' : L.key === 'AA' ? 'Focus on application, scenarios, troubleshooting, decisions.' : 'Focus on evaluation/creation, justification, or multi-step reasoning at an advanced level.'}

Learning Material (summary or text):
"""
${meta.content}
"""`.trim();

        tasks.push({
          topic: row.topic,
          level: L.key,
          format: fmt,
          count: cnt,
          prompt
        });
      }
    }
  }
  return tasks;
}





  async function callModelStrict(prompt, model){
  const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": apikey,
      "HTTP-Referer":"https://ivnx9.github.io",
      "X-Title":"Exam Miner 2.0"
    },
    body: JSON.stringify({
      model,
      messages: [
        { role: "system", content: "You generate exam items only, following instructions exactly."},
        { role: "user", content: prompt }
      ]
    })
  });
  const data = await res.json();
  if (data.error) throw new Error(data.error.message || "Model error");
  return data.choices?.[0]?.message?.content || "";
}

async function generateCellExactly(task, model){
  // Try up to 2 passes to hit exact count
  let text = await callModelStrict(task.prompt, model);
  let {items} = extractQuestions(text);

  if (items.length === task.count) return items;

  // Too many → trim
  if (items.length > task.count) return items.slice(0, task.count);

  // Too few → ask for the missing remainder once
  const missing = task.count - items.length;
  if (missing > 0){
    const follow = `
Earlier you produced ${items.length} ${task.format} question(s) for "${task.topic}" at level ${task.level}.
Generate exactly ${missing} MORE ${task.format} question(s), continuing the numbering from ${items.length + 1}.
Do not repeat prior questions. Do not include an answer key.
`.trim();
    const more = await callModelStrict(follow, model);
    const parsed = extractQuestions(more).items;
    const needed = parsed.slice(0, missing);
    return items.concat(needed);
  }

  return items; // fallback
}



function renderExamFromBlocks(blocks, meta){
  // blocks: array of {topic, format, items: [q1,q2,...]}
  // Create Title
  const lines = [];
  const title = `${meta.topic || meta.subject || "Exam"}`.trim();
  lines.push(`${title}`);
  lines.push("");

  // Render grouped by Topic, then by Format
  const byTopic = {};
  for (const b of blocks){
    byTopic[b.topic] ||= {};
    byTopic[b.topic][b.format] ||= [];
    byTopic[b.topic][b.format].push(...b.items);
  }
/*
  for (const [topic, formats] of Object.entries(byTopic)){
    lines.push(`${topic.toUpperCase()}`);
    for (const [fmt, items] of Object.entries(formats)){
      lines.push(`${fmt}`);
      // Re-number within format section
      items.forEach((txt, i) => {
        // normalize leading number
        const body = txt.replace(/^\s*_?\s*\d+[\.\)]\s*/, '');
        lines.push(`${i+1}. ${body}`);
      });
      lines.push("");
    }
    lines.push("");
  }
*/
  for (const [fmt, items] of Object.entries(formats)){
  lines.push(`${fmt}`);
  items.forEach((txt, i) => {
    if (fmt === "True or False") {
      // keep leading underscore and re-number with underscore
      const body = txt.replace(/^\s*_?\s*\d+[\.\)]\s*/, ''); // strip any existing number/underscore
      lines.push(`_ ${i+1}. ${body}`);
    } else {
      // normal numbering (no underscore)
      const body = txt.replace(/^\s*_?\s*\d+[\.\)]\s*/, '');
      lines.push(`${i+1}. ${body}`);
    }
  });
  lines.push("");
}

  // We didn’t collect per-item answers here (MC/TF). If you want an answer key:
  // Simple heuristic: pull lines like "A.", "B.", etc. from items is unreliable.
  // Better: ask the model for answer key AFTER assembling—all at once, from the rendered paper.
  return lines.join("\n");
}

async function generateAnswerKeyFromPaper(paperText, model){
  const prompt = `
Produce ONLY the answer key for the exam below.
- For Multiple Choice: "1. A", "2. C", ...
- For True/False: "1. True/False", ...
- Do not rewrite the exam, only the key lines.

Exam:
"""
${paperText}
"""`.trim();
  const key = await callModelStrict(prompt, model);
  return key.trim();
}


      
      // =========================================

function addTosRow(){
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td><input placeholder="Topic name" /></td>
    <td><input type="number" min="0" max="100" step="1" value="25" /></td>
    <td><input type="number" min="0" max="100" step="1" value="40" /></td>
    <td><input type="number" min="0" max="100" step="1" value="40" /></td>
    <td><input type="number" min="0" max="100" step="1" value="20" /></td>
    <td class="rowTotal">100%</td>
    <td><button type="button" onclick="removeTosRow(this)">✖</button></td>`;
  document.getElementById('tosBody').appendChild(tr);
}
function removeTosRow(btn){ btn.closest('tr').remove(); }

// ============= new extractor markdown =======
  // Helpers
  const readAsArrayBuffer = f => new Promise((res, rej) => {
    const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsArrayBuffer(f);
  });
  const readAsText = f => new Promise((res, rej) => {
    const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsText(f);
  });

  // ---- File-type specific extractors (return PLAIN TEXT for your AI) ----
  async function extractDOCX(file){
    const ab = await readAsArrayBuffer(file);
    // Raw text (no HTML) fits your “plain text to AI” flow best:
    const { value } = await window.mammoth.extractRawText({ arrayBuffer: ab });
    return (value || "").trim();
  }

  async function extractXLSX_CSV(file, ext){
    let wb;
    if (ext === 'csv'){
      const text = await readAsText(file);
      wb = XLSX.read(text, { type: 'string' });
    } else {
      const ab = await readAsArrayBuffer(file);
      wb = XLSX.read(ab, { type: 'array' });
    }
    // First sheet → TSV-like plain text
    const sheet = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true });
    return rows.map(r => r.map(c => (c == null ? "" : String(c))).join("\t")).join("\n");
  }

  async function extractPPTX(file){
    const ab = await readAsArrayBuffer(file);
    const zip = await JSZip.loadAsync(ab);
    const slideFiles = Object.keys(zip.files)
      .filter(p => /^ppt\/slides\/slide\d+\.xml$/.test(p))
      .sort((a,b) =>
        parseInt(a.match(/slide(\d+)\.xml/)[1],10) -
        parseInt(b.match(/slide(\d+)\.xml/)[1],10)
      );

    let out = [];
    for (let i=0;i<slideFiles.length;i++){
      const xml = await zip.files[slideFiles[i]].async('text');
      const runs = Array.from(xml.matchAll(/<a:t>([\s\S]*?)<\/a:t>/g)).map(m=>m[1]);
      const text = runs.map(t => t.replace(/&lt;|&gt;|&amp;/g, s => ({'&lt;':'<','&gt;':'>','&amp;':'&'}[s])))
                       .map(s => s.trim()).filter(Boolean);
      if (text.length){
        out.push(`Slide ${i+1}:\n- ` + text.join("\n- "));
      }
    }
    return out.join("\n\n") || "(No extractable text)";
  }

  async function extractPDF(file){
    const ab = await readAsArrayBuffer(file);
    const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
    let pages = [];
    for (let p=1; p<=pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      const strings = content.items.map(it => (it.str||"").trim()).filter(Boolean);
      const text = strings.join(" ").replace(/\s{2,}/g," ").trim();
      if (text) pages.push(`Page ${p}:\n${text}`);
    }
    return pages.join("\n\n") || "(No extractable text)";
  }

  async function extractHTML(file){
    const html = await readAsText(file);
    // Strip tags to plain text
    const doc = new DOMParser().parseFromString(html, "text/html");
    return (doc.body?.innerText || "").trim();
  }

  // ---- Main router: returns CLEAN PLAIN TEXT ----
  async function extractLocally(file){
    const ext = (file.name.split('.').pop() || '').toLowerCase();
    if (ext === 'docx') return extractDOCX(file);
    if (ext === 'xlsx' || ext === 'csv') return extractXLSX_CSV(file, ext);
    if (ext === 'pptx') return extractPPTX(file);
    if (ext === 'pdf')  return extractPDF(file);
    if (ext === 'html' || ext === 'htm') return extractHTML(file);
    if (ext === 'txt')  return readAsText(file);
    throw new Error("Unsupported file type: ." + ext);
  }

// ======= end of new extractor ======
    
/*
async function generateExam() {
  const fileInput = document.getElementById('material');
  const file = fileInput.files[0];
  if (!file) return alert('Please upload a learning material file.');

  setLoader("Extracting content from file...");
    const extractedText = await extractLocally(file);
    if (!extractedText || !extractedText.trim()) {
      hideLoader(); return alert("Could not extract any text from the file.");
    }
  
    
  const formData = new FormData();
  formData.append("file", file);

  const extractRes = await fetch("https://pymultiextractor.onrender.com/extract", {
    method: "POST",
    body: formData
  });

  const extractData = await extractRes.json();
  if (!extractData.content) {
    hideLoader();
    return alert("Failed to extract file content.");
  }
  

  setLoader("Summarizing content...");
  const cleanedContent = await summarizeContent(extractData.content);
  if (!cleanedContent) {
    hideLoader();
    return alert("Summarization failed.");
  }

  setLoader("Generating exam from TOS...");
  const prompt = buildPrompt(cleanedContent);
  const aiResponse = await sendToAI(prompt);

  hideLoader();
  document.getElementById("output").innerHTML = (aiResponse || "No response from AI.").replace(/\n/g, "<br>");

  //document.getElementById("output").textContent = aiResponse || "No response from AI.";
}
*/
/*
async function generateExam() {
  const fileInput = document.getElementById('material');
  const file = fileInput.files?.[0];
  if (!file) return alert('Please upload a learning material file.');

  try {
    setLoader("Extracting content from file…");
    const extractedText = await extractLocally(file);
    if (!extractedText || !extractedText.trim()) {
      hideLoader(); return alert("Could not extract any text from the file.");
    }


    // Auto mode: summarize only if very long
    const NEED_SUMMARY = extractedText.length > 10000;  // tweak threshold as needed
    setLoader(NEED_SUMMARY ? "Summarizing content…" : "Using full content…");
    const cleanedContent = NEED_SUMMARY ? (await summarizeContent(extractedText)) : extractedText;
    if (!cleanedContent) { hideLoader(); return alert("Summarization failed."); }

    
    setLoader("Generating exam from TOS…");
    const prompt = buildPrompt(cleanedContent);
    const aiResponse = await sendToAI(prompt);

    hideLoader();
    
    //document.getElementById("output").innerHTML =
     // (aiResponse || "No response from AI.").replace(/\n/g, "<br>");

    const safe = DOMPurify.sanitize((aiResponse || "No response").replace(/\n/g, "<br>"));
    document.getElementById("output").innerHTML = safe;
  } catch (e) {
    hideLoader();
    console.error(e);
    alert("Error: " + (e?.message || e));
  }
}
*/

  async function generateExam(){
  const fileInput = document.getElementById('material');
  const file = fileInput.files?.[0];
  if (!file) return alert('Please upload a learning material file.');

  // Read meta
  const subject = document.getElementById('subject').value.trim();
  const topic = document.getElementById('topic').value.trim();
  const grade = document.getElementById('grade').value.trim();
  let total = parseInt(document.getElementById('questionCount').value,10);
  if (!Number.isFinite(total) || total<=0) total = 20;

  const selectedFormats = Array.from(document.querySelectorAll('.format:checked')).map(cb=>cb.value);
  if (!selectedFormats.length) return alert('Select at least one exam format.');

  try {
    setLoader("Extracting content…");
    const extractedText = await extractLocally(file);
    if (!extractedText || !extractedText.trim()) { hideLoader(); return alert("No extractable text."); }

    // Auto-summarize if long
    const NEED_SUMMARY = extractedText.length > 10000;
    setLoader(NEED_SUMMARY ? "Summarizing content…" : "Using full content…");
    const content = NEED_SUMMARY ? (await summarizeContent(extractedText)) : extractedText;
    if (!content) { hideLoader(); return alert("Summarization failed."); }

    if (!validateTOS()) { hideLoader(); return alert("Fix TOS first."); }
    const plan = allocateItemsByTOS(total);

    // Build strict tasks
    const model = document.getElementById("model").value;
    const meta = {subject, topic, grade, content};
    const tasks = buildCellTasks(plan, selectedFormats, meta);

    // Execute tasks
    setLoader("Generating exam from TOS…");
    const blocks = [];
    for (const t of tasks){
      const items = await generateCellExactly(t, model);
      blocks.push({ topic: t.topic, format: t.format, items });
    }

    // Assemble paper
    const paper = renderExamFromBlocks(blocks, {subject, topic});
    // Optionally get answer key
    const includeKey = document.getElementById('answerKey').checked;
    const key = includeKey ? await generateAnswerKeyFromPaper(paper, model) : "";

    hideLoader();
    const finalText = includeKey ? `${paper}\n\nAnswer Key\n${key}` : paper;
    const safe = DOMPurify.sanitize(finalText.replace(/\n/g, "<br>"));
    document.getElementById("output").innerHTML = safe;

    // (Nice) Show allocation preview
    document.getElementById('tosStatus').textContent =
      'Allocation → ' + plan.map(p => `${p.topic}: ${p.total} (RU ${p.RU}, AA ${p.AA}, HOTS ${p.HOTS})`).join(' | ');

  } catch (e){
    hideLoader();
    console.error(e);
    alert("Error: " + (e?.message || e));
  }
}


function buildPrompt(content) {
  const subject = document.getElementById('subject').value.trim();
  const topic = document.getElementById('topic').value.trim();
  const grade = document.getElementById('grade').value.trim();
  let questionCount = parseInt(document.getElementById('questionCount').value,10);
  if (!Number.isFinite(questionCount) || questionCount <= 0) questionCount = 20;

  if(!validateTOS()){
    throw new Error('Please fix the TOS before generating the exam.');
  }
  const plan = allocateItemsByTOS(questionCount); // [{topic, total, RU, AA, HOTS}, ...]

  const formats = Array.from(document.querySelectorAll('.format:checked')).map(cb=>cb.value);
  const difficulty = document.querySelector('input[name="difficulty"]:checked')?.value || "Any";
  const shuffle = document.getElementById('shuffle').checked ? "Yes" : "No";
  const answerKey = document.getElementById('answerKey').checked ? "Yes" : "No";

  const tosBlock = plan.map(p =>
    `- ${p.topic}: total ${p.total} items → RU=${p.RU}, AA=${p.AA}, HOTS=${p.HOTS}`
  ).join('\n');

if (!formats.length) throw new Error('Select at least one exam format.');

const onlyThese = formats.join(', ');
  
  return `You are an Exam Generator AI. Generate ONLY the exam (plain text, printable). No markdown, no extra commentary.
  
STRUCTURE & STYLE:
- Title centered on top (include Topic and Grade if provided).
- Create sections for the selected formats only (${formats.join(', ')||'none specified'}).
- Multiple Choice: A–D choices.
- True/False: underscore before the number line.
- Identification/Essay: provide lines/underscores.
- Do NOT add markdown, bold, hashes, or separators.
- If a field is empty, omit it.

STRICT FORMAT RULE:
- Generate sections for these formats ONLY: ${onlyThese}.
- Do NOT include or mention any unselected format. Do NOT print lines like "omitted" or "not included".


STRICT TOS ALLOCATION (non-negotiable):
Total items: ${questionCount}
Distribute items exactly by topic and cognitive level as follows:
${tosBlock}

GROUPING:
- Create separate subsections per Topic.
- Within each Topic, produce exactly the allocated counts for RU, AA, HOTS (you may mix levels, but final counts must match).
- Do not print the labels RU/AA/HOTS in the final exam; just ensure the questions reflect those levels.


Cognitive level mapping:
- RU = Remember/Understand
- AA = Apply/Analyze
- HOTS = Evaluate/Create or higher-order thinking

Subject: ${subject}
Topic: ${topic}
Grade Level: ${grade}
Difficulty bias: ${difficulty}
Shuffle Questions: ${shuffle}
Include Answer Key: ${answerKey}

Learning Material (clean summary):
"""
${content}
"""`;
}

      
/*
    function buildPrompt(content) {
      const subject = document.getElementById('subject').value;
      const topic = document.getElementById('topic').value;
      const grade = document.getElementById('grade').value;
      const questionCount = document.getElementById('questionCount').value;
      if (questionCount == null || questionCount == 0) {
        const questionCount = 20;
      }

      const formats = Array.from(document.querySelectorAll('.format:checked'))
                           .map(cb => cb.value).join(', ');

      const difficulty = document.querySelector('input[name="difficulty"]:checked')?.value || "Any";
      const shuffle = document.getElementById('shuffle').checked ? "Yes" : "No";
      const answerKey = document.getElementById('answerKey').checked ? "Yes" : "No";

      return `You are an Exam Generator AI. Based on the details below, generate a complete exam only. Strictly avoid and Do not use markdown formatting like **bold**, ## headings, or --- lines. Output plain text, neatly formatted like a printable exam paper. Avoid any instructions or message just the exam only. Follow this layout:

- Title: Centered on top, include the topic and grade level if available.
- For each section, add a clear heading (e.g., Multiple Choice).
- For Multiple Choice: List questions with choices labeled A–D.
- For True or False: Use the underscores before the number and question
- For Identification & Essay: Leave underscores or blank space.
- Do not add extra characters or markdown syntax.
- don't use bold text or headings and don't add any message.
- on below if its value/content is missing avoid to include it on the exam.

Subject: ${subject}
Topic: ${topic}
Grade Level: ${grade}
Exam Formats: ${formats}
Number of Questions: ${questionCount}
Difficulty: ${difficulty}
Shuffle Questions: ${shuffle}
Include Answer Key: ${answerKey}

Learning Material converted into markdown:
"""
${content}
"""`;
    } */

    async function summarizeContent(text) {
      const model = document.getElementById("model").value;
      const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": apikey,
          "HTTP-Referer":"https://ivnx9.github.io",
          "X-Title":" Exam Miner 2.0"
        },
        body: JSON.stringify({
          model: model,
          messages: [
            { role: "system", content: "Summarize this learning material to include only the most important topics, keywords, concepts, and definitions. Ignore greetings or instructions." },
            { role: "user", content: text }
          ]
        })
      });
      const data = await res.json();
      if (data.error) throw new Error(data.error.message || 'Model error');
      console.log(data);
      return data.choices?.[0]?.message?.content || null;
    }

    async function sendToAI(prompt) {
      const model = document.getElementById("model").value;
      const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": apikey,
          "HTTP-Referer":"https://ivnx9.github.io",
          "X-Title":" Exam Miner 2.0"
        },
        body: JSON.stringify({
          model: model,
          messages: [
            { role: "system", content: "You are an expert AI Exam Generator with the applied TOS." },
            { role: "user", content: prompt }
          ]
        })
      });
      const data = await res.json();
      if (data.error) throw new Error(data.error.message || 'Model error');
      return data.choices?.[0]?.message?.content || null;
    }
  </script>

</body>
</html>
