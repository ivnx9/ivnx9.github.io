<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>File → Markdown (Browser-Only)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; max-width: 920px; margin: 24px auto; padding: 0 12px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin-top: 12px; }
    textarea { width: 100%; min-height: 320px; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #bbb; background: #f8f8f8; cursor: pointer; }
    #status { color: #555; }
  </style>
</head>
<body>
  <h1>File → Markdown (All in the Browser)</h1>

  <div class="card">
    <input id="file" type="file" />
    <button id="convertBtn">Convert to Markdown</button>
    <button id="downloadBtn" disabled>Download .md</button>
    <div id="status"></div>
  </div>

  <div class="card">
    <h3>Markdown Output</h3>
    <textarea id="out" placeholder="Your Markdown will appear here…"></textarea>
  </div>

  <!-- Pinned dependencies (UMD builds) -->
  <!-- DOCX -> HTML -->
  <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js" crossorigin="anonymous"></script>
  <!-- XLSX/CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" crossorigin="anonymous"></script>
  <!-- PPTX: unzip + read XML -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous"></script>
  <!-- PDF.js (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js" crossorigin="anonymous"></script>
  <!-- HTML -> Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/turndown@7.1.3/dist/turndown.js" crossorigin="anonymous"></script>

  <script>
    // --- Setup ---
    const fileEl = document.getElementById('file');
    const outEl = document.getElementById('out');
    const statusEl = document.getElementById('status');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    // PDF.js worker (must match the pdf.min.js version above)
    const pdfjsLib = window.pdfjsLib; // exposed by UMD build
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";

    const turndown = new TurndownService({ headingStyle: 'atx', codeBlockStyle: 'fenced' });

    function setStatus(msg) { statusEl.textContent = msg || ""; }
    function escapeHtml(s){ return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }

    const readAsArrayBuffer = (f) => new Promise((res, rej) => {
      const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsArrayBuffer(f);
    });
    const readAsText = (f) => new Promise((res, rej) => {
      const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsText(f);
    });

    // --- Converters to HTML ---
    async function docxToHtml(arrayBuffer) {
      const result = await window.mammoth.convertToHtml({ arrayBuffer });
      return result.value || "<p></p>";
    }

    function sheetToHtmlTable(workbook) {
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true });
      let html = "<table>\n";
      rows.forEach(row => {
        html += "<tr>";
        row.forEach(cell => {
          const safe = (cell === undefined || cell === null) ? "" : String(cell)
            .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
          html += `<td>${safe}</td>`;
        });
        html += "</tr>\n";
      });
      html += "</table>";
      return html;
    }

    async function xlsxCsvToHtml(file, ext) {
      if (ext === 'csv') {
        const text = await readAsText(file);
        const wb = XLSX.read(text, { type: 'string' });
        return sheetToHtmlTable(wb);
      } else {
        const ab = await readAsArrayBuffer(file);
        const wb = XLSX.read(ab, { type: 'array' });
        return sheetToHtmlTable(wb);
      }
    }

    async function pptxToHtml(arrayBuffer) {
      const zip = await JSZip.loadAsync(arrayBuffer);
      const slideFiles = Object.keys(zip.files)
        .filter(p => /^ppt\/slides\/slide\d+\.xml$/.test(p))
        .sort((a,b) => parseInt(a.match(/slide(\d+)\.xml/)[1],10) - parseInt(b.match(/slide(\d+)\.xml/)[1],10));

      let html = "";
      for (let i = 0; i < slideFiles.length; i++) {
        const xml = await zip.files[slideFiles[i]].async('text');
        const texts = Array.from(xml.matchAll(/<a:t>([\s\S]*?)<\/a:t>/g)).map(m => m[1]);
        const lines = texts.map(t => t.replace(/&lt;|&gt;|&amp;/g, s => ({'&lt;':'<','&gt;':'>','&amp;':'&'}[s]))).filter(s => s.trim().length);
        html += `<h2>Slide ${i+1}</h2>\n<ul>\n`;
        lines.forEach(t => { html += `<li>${escapeHtml(t)}</li>\n`; });
        html += `</ul>\n`;
      }
      return html || "<p>(No extractable text)</p>";
    }

    async function pdfToHtml(arrayBuffer) {
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let html = "";
      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const strings = content.items.map(it => (it.str || "").trim()).filter(Boolean);
        const text = strings.join(" ").replace(/\s{2,}/g, " ").trim();
        if (text) html += `<h3>Page ${p}</h3>\n<p>${escapeHtml(text)}</p>\n`;
      }
      return html || "<p>(No extractable text)</p>";
    }

    function txtToHtml(text) { return `<pre>${escapeHtml(text)}</pre>`; }
    function htmlToMarkdown(html) { return turndown.turndown(html); }

    // --- UI wiring ---
    convertBtn.addEventListener('click', async () => {
      const f = fileEl.files?.[0];
      if (!f) { alert("Choose a file first."); return; }
      setStatus("Converting…");
      outEl.value = "";
      downloadBtn.disabled = true;

      // extension (case-insensitive)
      const ext = (f.name.split('.').pop() || '').toLowerCase();

      try {
        let html = "";
        if (ext === "docx") {
          html = await docxToHtml(await readAsArrayBuffer(f));
        } else if (ext === "xlsx" || ext === "csv") {
          html = await xlsxCsvToHtml(f, ext);
        } else if (ext === "pptx") {
          html = await pptxToHtml(await readAsArrayBuffer(f));
        } else if (ext === "pdf") {
          html = await pdfToHtml(await readAsArrayBuffer(f));
        } else if (ext === "txt") {
          html = txtToHtml(await readAsText(f));
        } else if (ext === "html" || ext === "htm") {
          html = await readAsText(f);
        } else {
          setStatus("");
          alert("Unsupported file type: ." + ext);
          return;
        }

        const md = htmlToMarkdown(html);
        outEl.value = md;
        setStatus("Done ✓");
        downloadBtn.disabled = false;
      } catch (e) {
        console.error(e);
        setStatus("Error: " + (e?.message || e));
      }
    });

    downloadBtn.addEventListener('click', () => {
      const md = outEl.value || "";
      const base = (fileEl.files?.[0]?.name || 'output').replace(/\.[^.]+$/, '');
      const blob = new Blob([md], { type: "text/markdown;charset=utf-8" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = base + ".md";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    });
  </script>
</body>
</html>
